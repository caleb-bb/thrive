<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>README.html</title>
<meta http-equiv="Content-Type" content="application/xhtml+xml;charset=utf-8"/>
<link rel="stylesheet" type="text/css" media="all" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css"  />
<link rel="stylesheet" type="text/css" media="all" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/github.min.css"  /><meta name='viewport' content='width=device-width, initial-scale=1, shrink-to-fit=no'><style> body { box-sizing: border-box; max-width: 740px; width: 100%; margin: 40px auto; padding: 0 10px; } </style><script id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'></script><script src='https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js'></script><script>document.addEventListener('DOMContentLoaded', () => { document.body.classList.add('markdown-body'); document.querySelectorAll('pre[lang] > code').forEach((code) => { code.classList.add(code.parentElement.lang); }); document.querySelectorAll('pre > code').forEach((code) => { hljs.highlightBlock(code); }); });</script>
</head>

<body>

<p>#+title: Readme #+author: Caleb Beers</p>
<p>Thrive A game engine focused on small teams and procedural
generation</p>
<ul>
<li>Pre-Development Agenda ** Books</li>
</ul>
<ol type="1">
<li><em>Command Line Rust</em> to get started learning the
language.</li>
<li><em>Foundations of Game Engine Development</em>, vols I and II.
Learn the underlying math! This one requires the most attention.</li>
<li><em>Game Programming Patterns</em>, found at
https://gameprogrammingpatterns.com/. This is just to be read, not
worked out. If I want to use a pattern later, I can use this thing
called a search engine and write “<name of pattern> Rust”.</li>
</ol>
<p>Only the first one need be completely finished before starting
development. The others can be a read-as-we-go deal.</p>
<p>** Activities *** Game building Build a basic 3D game (by following a
tutorial) in Unity, Unreal 4, or both. The goal is to get familiar with
the features and what it feels like to build a game in each. A few hours
in each should suffice for the beginning, but /should be a recurring
step/, regularly returning to see what’s available on the “top level” of
oter engines. *** Research Consume many videos and podcasts on general
game engine development. Always be listening to them. /This should
primarily be high-level material/, focused on things like architecture
and processes rather than the niceties of code.</p>
<ul>
<li>Development (tentative)</li>
</ul>
<ol type="1">
<li>Bootstrap. This means <em>basic systems</em>, including, but not
limited to:
<ol type="1">
<li>File I/O</li>
<li>Logging</li>
</ol></li>
<li><em>Networking layer</em> for multiplayer. This means set up the
client and server, and at least get some text packets going in TCP.</li>
<li><em>Graphics API</em>. Pick a graphics library, such as OpenGL or
Vulcan or whatever, and figure out how we’re gonna initialize/interact
with it. Try to set up the abstraction so that we can change our minds
later if we want, if that’s feasible.</li>
<li><em>Asset pipeline</em>, at a high level. Just determine how we’re
gonna import assets and get the interface in place.</li>
<li><em>UI</em>, meaning UI for the game designer. This happens at such
an early stage because we need to be able to dick with the engine from
the developer perspective during developing.</li>
<li><em>World and scene graph</em>. A scene graph, or world graph, is
just a DAG that puts objects in a hierarchy. If I move my arm, then my
hand must move, too. We could represent this in our scene graph by
making the hand node a child of the arm node. Simple.</li>
<li><em>Client state</em> for client and server. Suppose an object moves
around in the server and all the clients need to see it. The plumbing in
the networking layer to enable that must be built at this stage.</li>
<li><em>Physics</em>. Pick a physics engine or write one. Probably pick
one, at least to begin. Figure out how to treat physics over the
network. Think: how would two people play a ping-pong game over this
network? How would the physics work?</li>
<li><em>Tools</em>. All the level editors, asset importers, whatever
else. The mantra at this stage will have to be “I am the only person who
actually likes the terminal”, because game devs want pointy-clicky
tools.</li>
</ol>

</body>
</html>
